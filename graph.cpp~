#include "graph.hpp"
#include <algorithm>
#include <iostream>
#include <limits>
#include <exception>



namespace Graph
{
  //Edge
  Edge::Edge()
  {
    
  }

  Edge::Edge(Vertex* from, Vertex* to, int w)
  {
    From   = from;
    To     = to;
    Weight = w;
  }

  Edge::~Edge()
  {
    
  }
  
  int Edge::getWeight() const
  {
    return Weight;
  }
  
  Vertex* Edge::getFrom()
  {
    return From;
  }

  Vertex* Edge::getTo()
  {
    return To;
  }

  void Edge::setTo(Vertex* t)
  {
    To = t;
  }

  void Edge::setFrom(Vertex* f)
  {
    From = f;
  }

  void Edge::setWeight(int w)
  {
    Weight = w;
  }

  //Vertex
  Vertex::Vertex()
  {
    parentPointer = this;
    Key = 1;
  }

  Vertex::Vertex(int n)
  {
    Name = n;
    parentPointer = this;
    Key = 1;
  }
  
  Vertex::~Vertex()
  {}
  
  int Vertex::getName()
  {
    return Name;
  }

  
  void Vertex::setName(int n)
  {
    Name=n;
  }

  int Vertex::getKey()
  {
    return Key;
  }

  void Vertex::setKey(int k)
  {
    Key=k;
  }

  Vertex* Vertex::getParentPointer()
  {
    return parentPointer;
  }

  void Vertex::setParentPointer(Vertex* v)
  {
    parentPointer = v;
  }

  Vertex* Vertex::getRoot()
  {
    if(parentPointer!=this)
      {
	return parentPointer->getRoot();
      }
    else
      {
	return this;
      }
  }

  std::vector<Edge*> Vertex::getEdges()
  {
    return edges;
  }
  
  void Vertex::setEdges(std::vector <Edge*> l)
  {
    edges = l;
  }

  void Vertex::addEdge(Edge* l)
  {
    edges.push_back(l);
  }

  //Graph

  bool Compare(const Edge* a, const Edge* b)
  {
    return a->getWeight() > b->getWeight();
  }

  Graph::Graph()
  {
  }

  Graph::Graph(int n)
  {
    for(int i=0;i<n;++i)
      {
	v.push_back(new Vertex(i+1));
	
      }

#ifdef HEAP
    std::make_heap(e.begin(),e.end(),Compare);
#endif

  }

  Graph::~Graph()
  {}

  void Graph::addEdge(int from, int to, int cost)
  {
    Edge* ed = new Edge(this->getVertex(from),this->getVertex(to),cost);
    this->getVertex(from)->addEdge(ed);
    this->getVertex(to)->addEdge(ed);
    e.push_back(ed);
#ifdef HEAP
    std::push_heap(e.begin(),e.end(),Compare);
#endif
   

  }
  
  Vertex* Graph::getVertex(int n)
  {
    //    std::cout<<"getVertex"<<std::endl;
    return v[n];
  }

  void Graph::Clustering(int n)
  {
    
    int count=0;
    int k = v.size();
    std::cout<<"ke="<<k<<std::endl;
    while(k>n)
      {
	Edge*   edge  = e.front();
	Vertex* from  = edge->getFrom();
	Vertex* to    = edge->getTo();
	Vertex* fRoot = from->getRoot();
	Vertex* tRoot = to->getRoot();
	if(fRoot!=tRoot){
#ifdef DEBUG
	  std::cout<<from->getName()<<"<-->"<<to->getName()<<std::endl;
#endif
	  if(fRoot->getKey() >= tRoot->getKey())
	    {
	      fRoot->setKey(fRoot->getKey() + tRoot->getKey());
	      tRoot->setParentPointer(fRoot);
	    }
	  else
	    {
	      tRoot->setKey(fRoot->getKey() + tRoot->getKey());
	      fRoot->setParentPointer(tRoot);
	    }
	  ++count;
	  --k;
	}
#ifdef HEAP	
	std::pop_heap(e.begin(),e.end(),Compare);
#endif
	//	std::cout << e.back()->getWeight()<<std::endl;
	e.pop_back();


      }

    while(e.front()->getFrom()->getRoot() == e.front()->getTo()->getRoot())
      {
#ifdef DEBUG
	std::cout<<e.front()->getFrom()->getName()<<" "<<e.front()->getTo()->getName()<<" "<<e.front()->getWeight()<<std::endl;
#endif
#ifdef HEAP
	std::pop_heap(e.begin(),e.end(),Compare);
#endif
	e.pop_back();
      }

    std::cout<<"spacing = "<<e.front()->getWeight()<<std::endl;
    std::cout<<k<<std::endl;
    
  }

  int Graph::BellFo(int s)

  {
    int V = v.size();
    float** A = new float*[V];
    for(int i=0; i<V;++i)
      A[i] = new float[V];

    float inf = std::numeric_limits<float>::infinity(); 
	
    for(int ver=0;ver<V;++ver)
      {
	for(int i=0;i<V;++i)
	  {
	    A[ver][i]=inf;
	  }
      }

    for(int ind=0;ind<V;++ind)
      A[s-1][ind]=0;

    int count;
    for(int i=1;i<V;++i)
      {
	count = 0 ;
	for(std::vector<Edge*>::iterator eit = e.begin();eit!=e.end();++eit)
	  {
	    int u = (*eit)->getFrom()->getName();
	    int v = (*eit)->getTo()->getName();
	    int w = (*eit)->getWeight();

	    if(A[v-1][i] > A[u-1][i-1] + w)
	      {

		for(int z = i; z<V; ++z)
		  A[v-1][z] = A[u-1][i-1]+w;
		
	      }
	    count++;
	  }
      }
    
    bool hasNegativeCycle = false;
    for(int ind=0;ind<V;ind++)
      hasNegativeCycle = hasNegativeCycle or (A[ind][V-2]!=A[ind][V-1]);
    
    if(hasNegativeCycle){
      throw Exception();
    }
#ifdef DEBUG    
    else
      std::cout<<"No negative cyle detected"<<std::endl;
#endif    
    int min = A[0][V-1];

    for(int ind=0;ind<V;ind++){
#ifdef DEBUG
      std::cout<<"vertex["<<ind+1<<"] "<<A[ind][V-1]<<std::endl; 
#endif
      if(min>A[ind][V-1])
	min = A[ind][V - 1];
    }
#ifdef DEBUG
    std::cout<<std::endl<<std::endl<<"shortest shortest path "<<min<<std::endl;
#endif
    for(int i=0;i<V;++i)
      delete[] A[i];
    delete[] A;
    return min;
  }

  int Graph::SSP()
  {
    int min=BellFo(v[0]->getName());

    for(int i=1;i<v.size();++i)
      {
	int lm = BellFo(v[i]->getName());
	if(min>lm)
	  min = lm;
      }

    return min;
  }

  std::vector< std::vector<Vertex*> > Graph::TSPEuclidRec(Vertex* curVer)
  {
    std::vector<Edge*> edges = curVer->getEdges();
    std::vector< std::vector<Vertex*> > pathacc;
    int tmpKey = curVer->getKey();
    curVer->setKey(0);
    for(std::vector< Edge* >::iterator i= edges.begin(); i!=edges.end();++i)
      {
	Vertex* tmpVer = (*i)->getTo();

	if(tmpVer==curVer)
	  tmpVer = (*i)->getFrom();
	  
	if(tmpVer->getKey()!=0)
	  {
	    std::vector<std::vector<Vertex *> > subTsp =  TSPEuclidRec(tmpVer);
	    for(std::vector<std::vector<Vertex*> >::iterator j = subTsp.begin(); j!=subTsp.end();++j)
	      {
		(*j).insert((*j).begin(),curVer);
		pathacc.push_back(*j);
	      }
	    tmpVer->setKey(1);
	  }
      }
    curVer->setKey(tmpKey);
    if(!pathacc.empty())
      return pathacc;
    else
      {
	std::vector<std::vector<Vertex*> >res;
	std::vector<Vertex*> p;
	p.push_back(curVer);
	res.push_back(p);
	return res;

      }
  }

}
